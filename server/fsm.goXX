package server

import (
	"fmt"
	"net"
	"time"

	"github.com/taktv6/tbgp/config"
	"github.com/taktv6/tbgp/packet"
	tomb "gopkg.in/tomb.v2"
)

const (
	Cease       = 0
	Idle        = 1
	Connect     = 2
	Active      = 3
	OpenSent    = 4
	OpenConfirm = 5
	Established = 6
)

type FSM struct {
	t          *tomb.Tomb
	state      int
	setStateCh chan int
	getStateCh chan int
	local      net.IP
	remote     net.IP
	localASN   uint16
	remoteASN  uint16
	neighborID uint32
	routerID   uint32

	con       *net.TCPConn
	cons      map[*net.TCPConn]struct{}
	conCh     chan *net.TCPConn
	conFailCh chan conErr

	connectRetryTime    time.Duration
	connectRetryTimer   *time.Timer
	connectRetryCounter int

	holdTimeConfigured time.Duration
	holdTime           time.Duration
	holdTimer          *time.Timer

	keepaliveTime  time.Duration
	keepaliveTimer *time.Timer
}

type conErr struct {
	con *net.TCPConn
	err error
}

func NewFSM(c config.Peer) *FSM {
	fsm := &FSM{
		setStateCh:         make(chan int),
		getStateCh:         make(chan int),
		cons:               make(map[*net.TCPConn]struct{}, 0),
		conCh:              make(chan *net.TCPConn),
		holdTimeConfigured: time.Duration(c.HoldTimer),
		holdTimer:          time.NewTimer(0),
		keepaliveTime:      time.Duration(c.KeepAlive),
		keepaliveTimer:     time.NewTimer(0),
	}

	fsm.t.Go(fsm.stateManager)
	return fsm
}

func (fsm *FSM) stateManager() error {
	for {
		select {
		case s := <-fsm.setStateCh:
			fsm.state = s
			continue
		case fsm.getStateCh <- fsm.state:
			continue
		case <-fsm.t.Dying():
			return nil
		}
	}
}

func (fsm *FSM) GetState() int {
	return <-fsm.getStateCh
}

func (fsm *FSM) setState(s int) {
	fsm.setStateCh <- s
}

func (fsm *FSM) connect() {
	c, err := net.DialTCP("tcp", &net.TCPAddr{IP: fsm.local}, &net.TCPAddr{IP: fsm.remote, Port: BGPPORT})
	if err != nil {
		return
	}
	fsm.conCh <- c
}

func (fsm *FSM) connectionManager() error {
	for {
		select {
		case c := <-fsm.conCh:
			s := fsm.GetState()
			if s == Idle || s == Established {
				c.Close()
			}
			err := fsm.sendOpen(c)
			if err != nil {
				continue
			}
			fsm.cons[c] = struct{}{}
			if s < OpenSent {
				fsm.setState(OpenSent)
			}
		case f := <-fsm.conFailCh:
			delete(fsm.cons, f.con)
			if len(fsm.cons) == 0 {
				fsm.setState(Idle)
			}
		case <-fsm.t.Dying():
			return nil
		}
	}
}

func (fsm *FSM) sendOpen(c *net.TCPConn) error {
	msg, err := packet.EncodeOpenMsg(&packet.BGPOpen{
		Version:       BGPVersion,
		AS:            fsm.localASN,
		HoldTime:      uint16(fsm.holdTimeConfigured),
		BGPIdentifier: fsm.routerID,
		OptParmLen:    0,
	})
	if err != nil {
		return fmt.Errorf("Unable to generate OPEN message: %v", err)
	}

	_, err = c.Write(msg)
	if err != nil {
		return fmt.Errorf("Unable to send OPEN message: %v", err)
	}

	return nil
}
